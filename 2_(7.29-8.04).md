## Algorithm

## Review
### The JVM Architecture Explained
* JVM可以划分为3个子系统：类加载器子系统，运行时数据区，执行引擎
#### 类加载子系统
* 实现动态类加载功能
* 当在运行时而非编译期第一次引用一个类时，类加载子系统会加载，链接和初始化该类文件
* 加载：
    * Bootstrap ClassLoader：从Bootstrap类路径中加在rt.jar
    * Extension ClassLoader：加载jre\lib路径中的类
    * Application ClassLoader：加载应用级别路径以及环境变量中配置的路径中的类
* 类加载时遵循双亲委托算法
* 链接：
    * 验证：验证字节码文件的正确性
    * 准备：为所有静态变量分配内存并赋默认值
    * 解析：用方法区的实际引用替换所有内存中的符号引用
* 初始化：
    * 为所有的静态变量赋实际值，所有的静态块代码将被执行
#### 运行时数据区
1. 方法区：每个JVM只有一个方法区，所有类级别的数据会存于此区域，包括静态变量
2. 堆区：每个JVM只有一个堆区，数组、对象及其对应的实例变量存于此区域
3. 栈区：每个线程对应一个运行时栈，每次方法调用都会在栈中创建栈帧，所有的局部变量存于此区
    * 局部变量数组：存储方法中涉及的局部变量
    * 操作数栈：用来执行操作的运行时工作区
    * 帧数据：存储与方法对应的符号，发生异常时，捕捉块的信息会存于该区域
* 由于方法区和堆区是多线程共享的，所以存于该区域的静态变量、数组、对象及其实例变量并不是线程安全的
* 由于栈区是各线程独有的，所以存于此区域的局部变量是线程安全的
4. PC寄存器：每个线程对应一个PC寄存器，用于保存当前正在执行的指令的地址，执行完后PC寄存器会更新为下一条指令的地址
5. 本地方法栈：每个线程对应一个本地方法栈，用于存储本地方法信息
#### 执行引擎
* 解释器：解释器解释代码速度较快，执行代码速度较慢；同一个方法调用多次，每次都会进行解释操作
* JIT编译器：将多次重复调用的字节码编译成本地代码，该本地代码用于直接调用，从而提高了系统性能
    1. 中间代码生成器：生成中间代码
    2. 代码优化器：用于优化中间代码
    3. 目标代码生成器：用于生成机器码或本地代码
    4. 分析器：用于发现热点代码，判断方法的调用次数
#### 垃圾回收器
* 收集并移除未被引用的对象，用反射方式创建的对象会像其他对象一样被垃圾回收
#### Java本地接口（JNI）
* JNI与本地方法库关联，为执行引擎提供本地库
#### 本地方法库
* 为执行引擎提供的本地库集合
## Tip

## Share
